use alloy::{
    primitives::{Bytes, U256},
    sol,
    sol_types::SolCall,
};
use alloc::vec::Vec;

sol! {
    #[sol(bytecode="6080604052348015600f57600080fd5b506004361060285760003560e01c8063c6c2ea1714602d575b600080fd5b603c603836600460a4565b604e565b60405190815260200160405180910390f35b600081600003605f57506000919050565b8160011480606d5750816002145b15607957506001919050565b60018060025b84811015609b5760006090848460bc565b93925050600101607f565b50909392505050565b60006020828403121560b557600080fd5b5035919050565b8082018082111560dc57634e487b7160e01b600052601160045260246000fd5b9291505056fea2646970667358221220013b9039a6c8a79766e9a3650fc5c376592c4c3552f3d7383d6635387172056264736f6c63430008180033")]
    contract Fibonacci {
        function fib(uint256 number) external view returns (uint256 result);
    }
}

pub fn encode_fib(num: U256) -> Vec<u8> {
    let contract = Fibonacci::fibCall {
        number: num,
    };
    contract.abi_encode()
}

pub fn decode_fib(bytes: &Bytes) -> Result<U256, anyhow::Error> {
    let number = Fibonacci::fibCall::abi_decode_returns(&bytes, true)?;
    Ok(number.result)
}